/* /local/src/master/nrn/src/nmodl/modl.h,v 4.2 1997/11/13 19:53:05 hines Exp */
/*
modl.h,v
 * Revision 4.2  1997/11/13  19:53:05  hines
 * LONGITUDINAL_DIFFUSION area {state} allowed in KINETIC block
 * same syntax as COMPARTMENT statement.
 * Units checking not established yet but area should be in um2 and
 * the COMPARTMENT volume units should be um3/um.
 * If the longitudinal area is affected by diam then diam should
 * appear explicitly in the area expression (generally as diam*diam/4
 * but perhaps some coordinate systems may have area that scales
 * linearly with diam).
 * Longitudinal diffusion works correctly with changing diameter and
 * rallbranch. It works with cvode but the linear solver for it
 * is currently equivalent to modified euler. With CVODE and
 * cvode.jacobian(1) to use a full matrix the approach to steady state
 * is fast if there are not too many states. It would be nice to
 * do some approimate tridiagonal system approaches for the built-in
 * linear solver.
 *
 * Revision 4.1  1997/08/30  20:45:27  hines
 * cvs problem with branches. Latest nmodl stuff should now be a top level
 *
 * Revision 4.0.1.1  1997/08/08  17:23:52  hines
 * nocmodl version 4.0.1
 *
 * Revision 4.0  1997/08/08  17:06:18  hines
 * proper nocmodl version number
 *
 * Revision 1.3  1997/07/20  15:38:46  hines
 * ion concentrations as states in cvode context now have cvode state
 * map pointer to the actual concentration variable. This guarantees
 * that the nernst calculations (done before any odes in models are called)
 * use the correct concentrations (set by cvode)
 *
 * Revision 1.2  1995/03/23  17:37:51  hines
 * CONSTRUCTOR and DESTRUCTOR for point processes
 *
 * Revision 1.1.1.1  1994/10/12  17:21:33  hines
 * NEURON 3.0 distribution
 *
 * Revision 9.174  1993/11/04  15:53:20  hines
 * port to solaris2 (no more warnings)
 *
 * Revision 9.160  1993/02/15  08:49:21  hines
 * linux
 *
 * Revision 9.159  93/02/11  16:55:44  hines
 * minor mods for NeXT
 * 
 * Revision 9.157  93/02/01  15:17:48  hines
 * static functions should be declared before use.
 * inline is keyword for some compilers.
 * 
 * Revision 9.86  90/12/12  18:17:18  hines
 * FROM index : index is an integer and cast to double wherever it
 * appears in expressons. It is not cast to int whenever it appears
 * in intexpr
 * 
 * Revision 9.78  90/12/10  16:56:42  hines
 * TABLE allowed in FUNCTION and PROCEDURE
 * 
 * Revision 9.76  90/12/07  09:27:18  hines
 * new list structure that uses unions instead of void *element
 * 
 * Revision 9.64  90/11/26  08:16:08  hines
 * external functions of type EXTDEF3 get two extra arguments.
 * The first arg is a pointer to _reset which should be set by the
 * function upon the occurence of a discontinuity.
 * The second arg is a pointer to a double which may be used by the
 * function to store information to help determine if a discontinuity
 * has occurred.  init.c gives a list of these functions.
 * 
 * Revision 9.58  90/11/20  17:24:03  hines
 * CONSTANT changed to PARAMETER
 * CONSTANT now refers to variables that don't get put in .var file
 * 
 * Revision 9.52  90/11/10  15:44:55  hines
 * nmodl: uses new NEURON { USEION ... format
 * passive.c works
 * 
 * Revision 9.50  90/11/02  08:31:48  hines
 * Allow UNITS block and make a  units defintion scale factor a static
 * variable so that it doesn't have to appear in the var file. eg.
 * UNITS { FARADAY = 96520 (coul) }
 * 
 * Revision 9.29  90/09/10  14:09:15  hines
 * certain functions specified in extdef2.h can have arguments which are
 * pointers to functions and pointers to vectors.
 * 
 * Revision 9.10  90/07/27  13:58:01  hines
 * nmodl handles declarations about right for first pass at this.
 * 
 * Revision 8.2  90/01/04  10:04:48  pusateri
 * added a SYSV ifdef to the existing TURBOC ifdef
 * 
 * Revision 8.1  89/09/29  16:26:06  mlh
 * ifdef for VMS and SYSV and some fixing of assert
 * 
 * Revision 8.0  89/09/22  17:26:36  nfh
 * Freezing
 * 
 * Revision 7.2  89/09/20  11:36:14  mdf
 * Test for VMS environment added to that for __TURBOC__
 * 
 * Revision 7.1  89/09/05  08:07:47  mlh
 * lappenditem() for use with lists of items which point to items
 * ITM(q) analogous to SYM(q)
 * 
 * Revision 7.0  89/08/30  13:32:07  nfh
 * Rev 7 is now Experimental; Rev 6 is Testing
 * 
 * Revision 6.0  89/08/14  16:26:51  nfh
 * Rev 6.0 is latest of 4.x; now the Experimental version
 * 
 * Revision 4.0  89/07/24  17:03:18  nfh
 * Freezing rev 3.  Rev 4 is now Experimental
 * 
 * Revision 3.2  89/07/18  11:55:07  mlh
 * first_time removed and MODEL_LEVEL used for declaration precedence
 * 
 * Revision 1.2  89/07/18  09:50:55  mlh
 * variable declaration precedence in submodels handled with
 * MODEL_LEVEL level prefix generated by merge. Lowest level takes
 * precedence.
 * 
 * Revision 1.1  89/07/06  14:52:31  mlh
 * Initial revision
 * 
*/

#include <stdio.h>
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <assert.h>

/*-
  The central data structure throughout modl is the list. Items can be
  inserted before a known item, inserted at the head of a list, or appended
  to the tail of a list. Items can be removed from a list. Lists can contain
  mixed types of items. Often an item which was an input token is edited and
  replaced by a string. The main types of items are strings and symbols. 
  Lists used are:
  
  intoken	Everytime the lexical analyser reads an input token it is
  		placed in this list. Much translation to C takes place during
  		parsing and most of that editing is done in this list. After
  		an entire block is processed, the tokens are moved as a group
  		to another list.
  		
  initfunc	main body of initmodel() from INITIAL. Automatic statements
  		of the form state = state0 are constructed here.
  constructorfunc	statements added to tail of allocation function
  destructorfunc	statements executed when POINT_PROCESS destroyed
  termfunc	main body of terminal() from TERMINAL
  modelfunc	main body of model() from EQUATION. SOLVE statements in the
  		equation block get expanded in this list
  procfunc	all remaining blocks get concatenated to this list. It
  		also gets the declarations. By prepending to procfunc, one
  		can guarantee that a declaration precedes usage.
  initlist	automatically generated statements that are to be executed
  		only once are constructed here. Contains setup of slist's
  		and dist's, etc. i.e. setup of indirect pointer lists to
  		state groups.
  
 Other lists (not global) but used in several files are:
 
  symlist[]	symbol table. One list for every beginning ascii character.
  		see symbol.c and symbol.h. See the Symbol structure below.
  symlistlist	for a stack of local symbol lists for LOCAL variables.
  		Local variable 'name' is  translated as _lname so that
  		there can be no conflict with the 'p' array.
  syminorder	Maintains order of variable declarations in the input file.
  		Used to get good order in the .var file.
  		
  firstlist	Statements that must appear before anything else in the
  		.c file. The only usage at this time is declaration of
  		LOCAL variables outside of blocks.
  		
  plotlist	variables to be plotted on first entry to scop
  
 Other lists used for local or very specific purposes are:
 
  indeplist	Independent variable info.
  parmlist	parameters in a SENS statement
  statelist	states used in a block containing a SENS statement
  sensinfo	see sens.c
  senstmt	see sens.c
  solvq		Item location and method stored when SOLVE statement occurs.
  		Solve statements are processed after all input is read.
  eqnq		Linear equations assembled using this list.
  
 Kinetic.c should be modified to make uniform use of List's instead of
 special structures for Reaction, Rlist, etc.
 */

typedef struct Item    List;		/* list of mixed items */
typedef struct Item {
	short           itemtype;
	union	{
			struct Item *itm;
			List *lst;
			char *str;
			struct Symbol *sym;
	}	element;	/* pointer to the actual item */
	struct Item    *next;
	struct Item    *prev;
}               Item;
#define ITEM0	(Item *)0
#define LIST0	(List *)0

#define ITERATE(itm,lst) for (itm = (lst)->next; itm != (lst); itm = itm->next)

/*-
The symbol structure gives info about tokens. Not all tokens need all
elements. Eg. the STRING uses only type and name.  Much storage could be
saved and much greater clarity could be attained if each type had its own
sub stucture.  Currently many of the structure elements serve very different
purposes depending on the type.
The following is a list of the current element usage:
 type		token number from parse1.y
 subtype	see definitions below
 u.i		integration method - flag for variable step
 		equation block - function number for generating variables
 u.str		scop variables - max,min,units for .var file
 used		state variable - temporary flag that it is used in an equation
 		equation block - number of state variables used (# unknowns)
		in parout.c - the numeric order in the .var file. Generated
		  and used in parout.c for the plotlist.
 usage		a token is used as a variable (DEP) or function (FUNC)
		Another field, EXPLICIT_DECL, is used to determine if a
		variable appears in the input file or is automatically
		created, thus helping to organize the .var file.
 araydim	arrays - dimension
 discdim	discrete variable - dimension
 varnum		state variable - during processing of a block containing
 		 equations in which simultaneous equations result; column
 		 number of state variable in the matrix.
 level		lowest submodel level number for declarations of this
 		 symbol. Used for parameters ( in explicit_decl()).
 		 The default value is 100.
 name		token name
*/
typedef struct Symbol {
	short           type;
	long            subtype;
#if NMODL
	short		nrntype;
#if CVODE
	int*		slist_info_; /* blunt instrument for retrieving ion concentration slist value */
#endif
	int		ioncount_; /* ppvar index for ions */
#endif
	union {
		int             i;
		char           *str;
	}               u;
	int             used;
	int             usage;
	int             araydim;
	int		discdim;
	int             varnum;	/* column number of state variable in
				 * equations */
	short		level;
	char           *name;
}               Symbol;
#define SYM0	(Symbol *)0

/*
 * this is convenient way to get the element pointer if you know what type
 * the item is 
 */
#define SYM(q)	((q)->element.sym)
#define STR(q)	((q)->element.str)
#define ITM(q)	((q)->element.itm)
#define LST(q)	((q)->element.lst)
/* types not defined in parser */
#define	SPECIAL 1
#define SYMBOL	1
#define ITEM	2
#define LIST	3
/*
 * An item type, STRING is also used as an item type 
 * An item type, VERBATIM is also used as an item type which is to be
 *  treated the same as a STRING but with no prepended space on output.
 */

/* subtypes */
#define	KEYWORD 01
#define PARM	02
#define	INDEP	04
#define	DEP	010		/* also in usage field */
#define	STAT	020
#define	ARRAY	040
#define	FUNCT	0100		/* also in usage field */
#define PROCED	0200
#define	NEGATIVE 0400
#define SEMI	01		/* ";" */
#define BEGINBLK 02		/* "{" */
#define ENDBLK	04		/* "}" */
#define DERF	01000
#define KINF	02000
#define NLINF	04000
#define DISCF	010000
#define STEP1   020000
#define PARF	040000
#define EXTDEF	0100000
#define LINF	0200000
#define UNITDEF 0400000L
#define EXTDEF2 01000000L	/* functions that can take array or function name arguments */
#define CONST	02000000L	/* constants that do not appear in .var file */
#define EXTDEF3 04000000L	/* get two extra reset arguments at beginning */
#define INTGER	010000000L	/* must be cast to double in expr */
#define EXPLICIT_DECL 01	/* usage field, variable occurs in input file */

extern char
		*emalloc(),	/* malloc with out of space checking */
		*stralloc(),	/* copies string to new space */
		*inputline(),	/* used only by parser to get title line */
		*inputtopar(),	/* used only by parser to get units */
		*Gets();	/* used only in io.c to get string from fin. */

#if 0
#if __TURBOC__ || SYSV || NeXT || LINUX
#else
extern char    *sprintf();
#endif
#endif

extern List
		*newlist(),	/* begins new empty list */
		*inputtext();	/* used by parser to get block text from
				 * VERBATIM and COMMENT */
extern Item
		*putintoken(),	/* construct symbol and store input tokens */
		*insertstr(),	/* before a known Item */
		*insertsym(),
		*linsertstr(),	/* prepend to list */
		*lappendstr(),	/* append to list */
		*linsertsym(),
		*lappendsym(),
		*lappenditem(),
		*lappendlst(),
		*next(),	/* not used but should be instead of q->next */
		*prev();

extern Symbol
		*install(),	/* Install token in symbol table */
		*lookup(),	/* lookup name in symbol table */
		*copylocal(),	/* install LOCAL variable symbol */
		*ifnew_parminstall();	/* new .var info only if
					 * not already done. */

extern char     finname[],	/* the input file prefix */
                buf[];		/* general purpose temporary buffer */

extern List
		*intoken,	/* Main list of input tokens */
		*initfunc,	/* see discussion above */
		*constructorfunc, 
		*destructorfunc, 
		*modelfunc,
		*termfunc,
		*procfunc,
		*initlist,
		*firstlist,
		*plotlist;

extern FILE
		*fin,		/* .mod input file descriptor */
		*fparout,	/* .var file */
		*fcout;		/* .c file */

extern Symbol
		*semi,		/* ';'. When seen on output, causes newline */
		*beginblk,	/* '{'. Used for rudimentary indentation */
		*endblk;	/* on output. */

/* the following is to get lint to shut up */
#if LINT
#undef assert
#define assert(arg)	{if (arg) ;}	/* so fprintf doesn't give lint */
extern char    *clint;
extern int      ilint;
extern Item    *qlint;
#define Sprintf		clint = sprintf
#define Fprintf		ilint = fprintf
#define Fclose		ilint = fclose
#define Fflush		ilint = fflush
#define Printf		ilint = printf
#define Strcpy		clint = strcpy
#define Strcat		clint = strcat
#define Insertstr	qlint = insertstr
#define Insertsym	qlint = insertsym
#define Linsertsym	qlint = linsertsym
#define Linsertstr	qlint = linsertstr
#define Lappendsym	qlint = lappendsym
#define Lappendstr	qlint = lappendstr
#define Lappenditem	qlint = lappenditem
#define Lappendlst	qlint = lappendlst
#define IGNORE(arg)	{if (arg);}
#define Free(arg)	free((char *)(arg))
#else
#define Sprintf		sprintf
#define Fprintf		fprintf
#define Fclose		fclose
#define Fflush		fflush
#define Printf		printf
#define Strcpy		strcpy
#define Strcat		strcat
#define Insertstr	insertstr
#define Insertsym	insertsym
#define Linsertsym	linsertsym
#define Linsertstr	linsertstr
#define Lappendsym	lappendsym
#define Lappendstr	lappendstr
#define Lappenditem	lappenditem
#define Lappendlst	lappendlst
#define IGNORE(arg)	arg
#define Free(arg)	free((void *)(arg))
#endif
