#include <../../nmodlconf.h>
/* /local/src/master/nrn/src/nmodl/symbol.c,v 4.1 1997/08/30 20:45:37 hines Exp */
/*
symbol.c,v
 * Revision 4.1  1997/08/30  20:45:37  hines
 * cvs problem with branches. Latest nmodl stuff should now be a top level
 *
 * Revision 4.0.1.1  1997/08/08  17:24:04  hines
 * nocmodl version 4.0.1
 *
 * Revision 4.0  1997/08/08  17:06:31  hines
 * proper nocmodl version number
 *
 * Revision 1.2  1997/07/20  15:38:49  hines
 * ion concentrations as states in cvode context now have cvode state
 * map pointer to the actual concentration variable. This guarantees
 * that the nernst calculations (done before any odes in models are called)
 * use the correct concentrations (set by cvode)
 *
 * Revision 1.1.1.1  1994/10/12  17:21:37  hines
 * NEURON 3.0 distribution
 *
 * Revision 9.94  91/01/24  14:00:41  hines
 * translation error when last token of LOCAL statement was the first token
 * after the LOCAL statement. Fixed by changing symbols at the parser instead
 * of the lexical analyser.
 * 
 * Revision 9.76  90/12/07  09:27:29  hines
 * new list structure that uses unions instead of void *element
 * 
 * Revision 9.10  90/07/27  13:58:10  hines
 * nmodl handles declarations about right for first pass at this.
 * 
 * Revision 8.1  89/11/01  10:19:06  mlh
 * identical names in nested LOCAL statements declared incorrectly.
 * The problem was fixed by not allowing extra _l prepended to
 * an already local variable.
 * 
 * Revision 8.0  89/09/22  17:27:02  nfh
 * Freezing
 * 
 * Revision 7.0  89/08/30  13:32:40  nfh
 * Rev 7 is now Experimental; Rev 6 is Testing
 * 
 * Revision 6.0  89/08/14  16:27:19  nfh
 * Rev 6.0 is latest of 4.x; now the Experimental version
 * 
 * Revision 4.0  89/07/24  17:03:50  nfh
 * Freezing rev 3.  Rev 4 is now Experimental
 * 
 * Revision 3.2  89/07/18  11:55:26  mlh
 * first_time removed and MODEL_LEVEL used for declaration precedence
 * 
 * Revision 1.2  89/07/18  09:50:47  mlh
 * variable declaration precedence in submodels handled with
 * MODEL_LEVEL level prefix generated by merge. Lowest level takes
 * precedence.
 * 
 * Revision 1.1  89/07/06  14:51:28  mlh
 * Initial revision
 * 
*/

#include "modl.h"
#include "parse1.h"
#include "symbol.h"

List	*symlist[128];	/* symbol table: linked list
				first char gives which list to use,but*/

List *symlistlist;	 /* for a stack of local symbol lists */

symbol_init() {
	int i;
	symlistlist = newlist();
	for (i=0; i<128; i++) {	/* more than we need */
		symlist[i] = newlist();
	}
}

Symbol *
lookup(s)	/* find s in symbol table */
	char *s;
{
	Item *sp;

	ITERATE(sp, symlist[s[0]]) {
		if (strcmp(SYM(sp)->name, s) == 0) {
			return SYM(sp);
		}
	}
	return SYM0;	/* 0 ==> not found */
}

Symbol *
checklocal(sym)
	Symbol *sym;
{
	Item *sp;
	List *sl;
	char *s;

	s = sym->name;
	/* look in local lists */
	ITERATE(sl, symlistlist)
	ITERATE(sp, LST(sl)) {
		if (strcmp(SYM(sp)->name+2, s) == 0) { /*get past _l*/
			return SYM(sp);
		}
	}
	return sym;
}
	
Symbol *
install(s, t)	/* install s in the list symbol table with type t*/
	char *s;
	int t;
{
	Symbol *sp;
	List *sl;

	if (t == STRING) {
		sl = symlist[0];
	}else if (t == -1) {	/*install on top local list see below*/
		t = NAME;
		assert(symlistlist->next != symlistlist);
		sl = LST(symlistlist->next);
	}else{
		sl = symlist[s[0]];
	}
	sp = (Symbol *) emalloc(sizeof(Symbol));
	sp->name = stralloc(s, (char *)0);
	sp->type = t;
	sp->subtype = 0;
#if NMODL
	sp->nrntype = 0;
#if CVODE
	sp->slist_info_ = (int*)0;
#endif
#endif
	sp->u.str = (char *)0;
	sp->used = 0;
	sp->usage = 0;
	sp->araydim = 0;
	sp->discdim = 0;
	sp->level = 100;	/* larger than any reasonable submodel level */
	Linsertsym(sl, sp); /*insert at head of list*/
	return sp;
}

pushlocal()
{
	Item * q;
	q = linsertsym(symlistlist, SYM0); /*the type is irrelevant*/
	LST(q) = newlist();
}

poplocal() /* a lot of storage leakage here for symbols we are guaranteed
	not to need */
{
	List *sl;
	Item *i, *j;

	assert(symlistlist->next != symlistlist);
	sl = LST(symlistlist->next);
	for (i = sl->next; i != sl; i = j) {
		j = i->next;
		delete(i);
	}
	delete(symlistlist->next);
}

Symbol *
copylocal(s)
	Symbol *s;
{
	if (s->name[0] == '_') {
		Sprintf(buf, "%s", s->name);
	}else{
		Sprintf(buf, "_l%s", s->name);
	}
	return install(buf, -1);
}

